# Техническое задание — fsp_maze: библиотека + рендерер
Версия: 1.1 
- Владелец: vfhc26 
- Команда: ???
    - Developer: Ononim03(Тямур)
    - Developer:
    - Developer:

## 1) Цель
- Реализовать C++ библиотеку, подключаемую как `#include <fsp_maze>`, с простым пользовательским сценарием:
	- `initMaze();  // открывает окно и готовит карту`
	- вызовы методов игрока: `Player.left() / right() / up() / down()`, `Player.checkCell(...)`
	- автоматическая отрисовка после каждого действия игрока (с опцией «показывать пройденный путь» и «скорость хода»)
	- `closeMaze(); // корректно закрывает окно и освобождает ресурсы`
- Алгоритм прохождения лабиринта пишут пользователи, используя эти методы.
- Рендерер — часть библиотеки: окно и перерисовка управляются внутри `fsp_maze`.

## 2) Архитектура (высокоуровнево)
- `fsp_maze` (lib): статическая/динамическая библиотека + заголовок `fsp_maze.hpp`.
- Внутри lib есть рендерер (оконный цикл): создаётся в `initMaze()` и разрушается в `closeMaze()`.
- Пользовательский код — последовательные вызовы методов `Player.*()` и `Player.checkCell(...)` между `initMaze()` и `closeMaze()`.

## 3) Публичный API (черновой контракт)
- Пространство имён: `fsp::maze`. Заголовок: `fsp_maze.hpp`.
- Инициализация/завершение:
	- `void initMaze();`
	- `void initMaze(const MazeConfig& cfg);` // перегрузка с параметрами
	- `void closeMaze();`
- Настройки визуализации и шага:
	- `void setMoveSpeed(double cellsPerSecond);` // скорость хода и анимации
	- `void setPathTraceEnabled(bool on);`       // рисовать пройденный путь
	- `void setRenderEnabled(bool on);`          // включить/выключить отрисовку (debug)
- Игрок (глобальный интерфейс `Player` внутри `fsp::maze`):
	- `bool left(); bool right(); bool up(); bool down();` // один шаг на 1 клетку; true — ход выполнен
	- `CellInfo checkCell();`                   // информация о текущей клетке
	- `CellInfo checkCell(Direction d);`        // информация о соседней клетке по направлению
	- опционально: `std::array<CellInfo,4> neighbors();`
- Типы:
	- `enum class CellType { Empty, Wall, Coin, Monster, Trap, Start, Exit };`
	- `enum class Direction { Up, Down, Left, Right };`
	- `struct CellInfo { CellType type; bool passable; int x; int y; };`
	- `struct MazeConfig { int width=30, height=20; uint64_t seed=0; int coins=0; int monsters=0; bool traps=false; };`

Примечание:
- После успешного перемещения (`left/right/up/down`) библиотека автоматически перерисовывает окно.
- Если включён `setPathTraceEnabled(true)`, визуализируется маршрут.

Пример использования (идея):
```cpp
#include <fsp_maze>
using namespace fsp::maze;
int main() {
	initMaze();                 // откроет окно и сгенерирует карту по умолчанию
	setMoveSpeed(5.0);          // 5 клеток в секунду
	setPathTraceEnabled(true);  // рисуем пройденный путь

	// Пример «алгоритма»: идём вправо пока можно, затем вниз
	while (Player.right()) { /* шаги + авто-рендер */ }
	while (Player.down())  { /* шаги + авто-рендер */ }

	// Проверка соседней клетки сверху
	auto top = Player.checkCell(Direction::Up);
	if (top.passable) Player.up();

	closeMaze();
}
```

## 4) Модель мира и правила
- Поле: прямоугольная сетка (width×height).
- Клетки: Wall (непроходимая), Empty (проходимая), Coin (проходимая, подбирается), Monster (занята монстром), Trap (ловушка/дверь), Start, Exit.
- Игрок:
  - Доступные действия: шаг на 1 клетку в Up/Down/Left/Right (методы `Player.*()` возвращают false, если ход невозможен: стена/граница/занято).
  - Окружение: `checkCell()` — текущая клетка; `checkCell(Direction)` — соседняя клетка (соседями считаются 4 клетки по осям).
  - Сбор монет — автоматический при входе в клетку Coin; при включённой трассировке путь подсвечивается.
- Монстры: двигаются каждый такт по простому правилу (v1 — случайный шаг по доступным направлениям). Столкновение с игроком — проигрыш.
- Ловушки/комнаты: вход в триггер может закрыть «дверь» (меняет Empty→Wall на заданных позициях); некоторые ловушки однократные.
- Условия завершения: победа — достигнут Exit и собраны требуемые монеты; поражение — столкновение с монстром или нет доступных ходов (optional).

## 5) Пользовательский алгоритм
- Пользователь пишет последовательность вызовов `Player.*()` и `checkCell()` между `initMaze()` и `closeMaze()`.
- Библиотека сама отрисовывает изменения после каждого действия; скорость регулируется `setMoveSpeed`.
- Ввод с клавиатуры не требуется (по умолчанию алгоритм — кодом); интерактивный ввод возможен как расширение.

## 6) Рендерер (внутри библиотеки)
- Окно создаётся при `initMaze()` и закрывается при `closeMaze()`.
- После каждого успешного `Player.*()` — автоматический ре-рендер; учитывается `setMoveSpeed` и трассировка пути.
- MVP: консольная или простая 2D‑тайловая отрисовка; целевая — GUI (SDL2/SFML).

## 7) Нефункциональные требования
- C++17, сборка Makefile; Windows (Git Bash/MSYS2) и Linux.
- Поставляем: `libfsp_maze.(a|so|dll)` + `fsp_maze.hpp`; пример `fsp_maze_view`.
- Логи/ошибки: валидация входных данных `MazeConfig`, предсказуемость по `seed`.

## 8) Критерии приёмки
- Подключение `#include <fsp_maze>` и линковка — успешны.
- Демонстрационная программа со сценарием на `Player.*()` компилируется и отображает окно; ходы видны сразу.
- Параметры `setMoveSpeed` и `setPathTraceEnabled` влияют на отрисовку как ожидается.
- Монеты подбираются; ловушки меняют проходимость; столкновение с монстром приводит к поражению.

## 9) Вне объёма v1
- Сложный ИИ монстров, редактор уровней, UI‑меню, звук, сохранения прогресса, сеть, 3D.
